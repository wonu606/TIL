## 우아한 객체 지향 챕터2

## 변경점

1. 생성 주기, 제약 조건이 다른 객체들을 참조하여 발생하는 문제들을 해결하기 위해 객체 참조 -> `PK` 참조

## 문제 발생

1. 객체가 직접 함수를 호출한 부분들에 컴파일 에러 발생(객체 참조를 `PK`참조로 변경하여 발생한 에러)

## 해결

1. 새로운 `Validator` 객체를 만들어 그 안에서 해결하도록 변경

![Validator가 추가된 도메인 다이어그램](https://github.com/wonu606/TIL/assets/133995055/16874d52-c728-4557-8bb9-527ba326b77e)
![Validator가 추가된 서비스 다이어그램](https://github.com/wonu606/TIL/assets/133995055/9addd249-e263-478e-9bac-6f7e564de993)

## 배운 점

- ***새로운 객체를 만들어 문제를 모아둔 부분***   
  이렇게 할 경우 컴파일 에러 난 곳들을 한 객체에 몰아넣게 된다.   
  참조를 하여 수행되는 일은 비슷한 책임일 확률이 높고, 모아두고 나누는 방식을 사용한다면 책임 단위가 더 명확하게 볼 수 있을 것 같다.
- ***`validate`를 `Order`에서 수행하는 것이 아니라 따로 뺀 부분***   
  나는 `validate`를 검사해야 하는 객체에서 수행해야 한다는 고정 관념이 있었다.   
  하지만 항상 그렇게 할 이유가 없다. 오히려 `validate`가 복잡하다면 이처럼 나누는 방식이 더 좋다고 생각한다.
- ***`validate`를 객체 지향이 아닌 절차 지향적 코드로 변경한 부분***   
  객체 지향 코드의 단점은 전체 플로우를 한눈에 파악하기 힘들다는 것이다.(각 객체가 캡슐화되어 있기 때문에)   
  절차 지향 코드로 구현할 경우, 코드를 이해하기 쉽고 디버깅 시에도 용이할 것이다.   
  물론 결합도가 높아져 단위 테스트 시에 어려움이 있을 수 있으므로 트레이드오프를 잘 고려해야 할 것이다.

## 변경된 코드의 문제

1. 주문이 배송되었다면 -> `Delivery`의 상태를 변경하여야 한다. 이때 문제가 발생한다.   
   `Domain` 관점에서는 `Delivery` -> `Order`로 의존관계가 형성되어 있지만
   `Service`에서는 주문 배송 완료가 되었을 때 `Delivery` 상태를 변경하는 `OrderPayedService`가 `Delivery`를 의존하고 있다.
   패키지적으로 양방향 참조가 된다.

## 해결 방안

1. `OrderService`에서 `OrderPayedService`를 인터페이스로 추상화하여 가지고 있는 것이다.
   이렇게 변경할 경우, `Delivery`를 알 필요가 없고 `Delivery` 패키지에서 `OrderPayedService` 구현체를 구현하고 있으면
   단방향 참조가 된다.

![양방향 참조 해결 서비스 다이어그램](https://github.com/wonu606/TIL/assets/133995055/3b7a7d06-8494-49f8-9dd3-e2876d563b77)

## 참조

[우아한 객체 지향 영상 - 유투브](https://www.youtube.com/watch?v=dJ5C4qRqAgA&t=2977s)   
[우아한 객체 지향 챕터2 코드 - 깃허브](https://github.com/eternity-oop/Woowahan-OO-02-domain-service)
