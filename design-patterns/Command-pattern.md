# 커맨드 패턴
하나의 명령(기능)을 객체화한 패턴

## 예시
- 리모컨 버튼들(티비 켜기, 끄기, 볼륨 조절 등)을 캡슐화하고 있다.

## 요소
- Command: 실행될 행동
- Receiver: 커맨드 객체가 해당 객체를 호출하여 행동을 수행함, 행동에만 관심을 가지면 됨
- Invoker: Client의 요청을 받아 Receiver에게 전달하는 컨트롤러 객체
- Client: 명령을 내리는 객체

## 사용 예제
- GUI 버튼

## 장단점

### 장점
- 명령과 쿼리를 분리합니다.  
[명령-쿼리 분리 원칙](https://origogi.github.io/oop/%EB%AA%85%EB%A0%B9%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/)
- 명령이 실제 수행되는 시점에 제어할 수 있다.(예: 지연 실행, 큐에 저장 등)
- 명령을 취소하거나 재실행하는 기능을 쉽게 구현할 수 있다.
- 복잡한 명령들을 캡슐화하여 코드의 가독성을 향상시킨다.

### 단점
- 코드 복잡성이 증가할 수 있다.(간단한 명령이라도 Command클래스를 정의해야 하므로)
- 런타임 오버헤드가 증가할 수 있다.   
  (각각의 명령당 명령 객체를 생성하여, 메모리 사용량과 실행 시간이 증가될 수 있다.)   
  런타임 오버헤드: 프로그램이 실행되는 동안 발생하는 추가적인 처리 또는 메모리 사용

## 예제 코드
[예제코드 링크](https://github.com/wonu606/TIL/tree/main/design-patterns/code/src/main/java/com/wonu606/commandpattern)