# 데코레이터 패턴

- 클래스에 클래스와 같은 상속을 받는 객체를 합성하고, 기능 수행시 구성한 객체에 기능 수행을 위임하여 연결하는 방식
- 기능을 감쌀 수 있어 코드의 변경 없이 확장할 수 있다.(OCP)
- 런타임 단계에서 동적으로 추가하거나 변경도 가능하다.

## 필요 객체

### 컴포넌트(Component)

기본 인터페이스 데코레이터를 추가하여 기능을 확장할 수 있다.

### 구체 컴포넌트(Concrete Component)

컴포넌트 인터페이스를 구현한 클래스, 객체에 행동 부여한다.

### 데코레이터(Decorator)

컴포넌트를 감싸는 객체, 컴포넌트와 같은 인터페이스를 가진다.   
데코레이터는 자신이 감싸고 있는 컴포넌트의 메서드를 호출하고, 그 결과에 새로운 행동을 추가하거나 수정하여 반환한다.

### 구체 데코레이터(Concrete Decorator)

실제로 추가되는 기능을 구현하는 클래스, 데코레이터를 상속받아, 원래 객체에 추가할 기능을 구현한다.

## 사용 예제

- 커피 가게에서 토핑 추가시
- 런타임 단계에서 추가 행동을 객체에 할당해야 할 경우

## 장단점

### 장점

- 새 자식 클래스를 만들지 않고도 객체의 행동을 확장 할 수 있다.
- 런타임에 책임을 추가하거나 제거할 수 있다.
- 클래스 별로 다양한 행동을 구현할 수 있어 SRP를 지킨다.
- 본래 코드를 수정하지 않고 확장할 수 있다.(OCP)

### 단점

- 스택으로 추가되어 특정 래퍼만을 제거하기 어렵다.
- 많은 수의 작은 클래스들이 생성되어, 디자인이 복잡해질 수 있다.
- 코드나 디버깅을 통해 이해하기 힘들 수 있다.(재귀적) 구조적으로 이해해야 한다.

## 예제 코드

[예제코드 링크](https://github.com/wonu606/TIL/tree/main/design-patterns/code/src/main/java/com/wonu606/decoratorpattern)