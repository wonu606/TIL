# OOP
프로그램의 동작을 객체 단위로 위임하고, 객체 간의 협력을 통해 동작하는 프로그래밍 패러다임

## 생겨난 이유
프로그램이 거대해지면서 해결책이 필요했다. 동작 단위를 작게 나누어 수행하고, 협력을 통해 동작하는 아이디어를 생각하게 된다.

## 객체 지향의 특성

### 캡슐화(Encapsulation)
캡슐로 만들어 데이터를 외부로부터 보호하는 것   
   
객체는 객체에 할당된 책임을 완전히 수행해야 한다.   
캡슐화를 통해 프로세싱 중에도 객체가 책임을 완전히 수행한다는 것을 보장한다.   
   
접근 제어자(access modifier)을 통해 캡슐화할 수 있다.

### 상속(Inheritance)
기존에 정의된 클래스의 특성과 동작을 다른 클래스가 물려받는 것   
   
코드 재사용성이 증가하고 계층 구조를 형성하여 다형성을 지원한다.

### 다형성(Polymorphism)
같은 타입이지만, 다른 동작을 수행할 수 있는 성질을 의미한다.   
   
유연성이 증가하여 코드의 확장과 변경이 용이해진다.

### 추상화(Abstraction)
어떤 성질, 본질을 파악하여 불필요한 부분을 제거하고 공통적인 부분만 추출하는 것   
   
추상화를 잘해놓으면, 코어단의 수정 없이 상속을 통해 확장하기 수월하다.(확장성, 유연성 증가)   
또한, 잘 나누어져 있으므로 코드를 볼 때 이해하기 편하다.(가독성 증가)

### 오해
필요한 기능 단위로 추상화하여 상속할 수 있다. 하지만 그것은 잘못된 것이다.   
필요한 기능 단위로 나누게 되면 다형성을 이용하여 동작할 때, 원하지 않는 다른 동작을 할 수도 있다.

## 어떻게 객체를 설계해야 할까? SOLID
SOLID: 객체 지향적으로 잘 설계 되었는지 알기란 쉽지 않다.   
SOLID 원칙은 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 가이드 라인을 제공한다.   
   
- S: Single Responsibility Principle(단일 책임의 원칙)
- O: Open-Closed Principle(개방폐쇄의 원칙)
- L: Liskov Substitution Principle(리스코브 치환의 원칙)
- I: Interface Segregation Principle(인터페이스 분리의 원칙)
- D: Dependency Inversion Principle(의존성 역전의 원칙)

[SOLID 자세한 설명 링크](https://github.com/wonu606/TIL/blob/main/oop/SOLID.md)
