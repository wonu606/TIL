# SOLID
유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 적용할 수 있는 원칙

## S: SRP(Single Responsibility Principle: 단일 책임의 원칙)
***하나의 객체는 하나의 책임만 가져야 한다는 원칙***
- 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 함을 의미한다.(하나의 책임만을 가지므로)
- 하나의 책임만을 가지게 되면 책임 영역이 확실해지므로 변경으로 인한 연쇄 작용에서 자유로워질 수 있다.
- SOLID의 다른 원리들을 적용하는 기초가 된다.

### SRP 적용 방법
1. 각 클래스별 어떠한 책임을 가지는지 식별하고, 두 개 이상의 책임을 가질 경우 분리하여야 한다.

## O: OCP(Open-Closed Principle: 개방폐쇄의 원칙)
***소프트웨어 컴포넌트는 확장에는 열려 있어야 하고 수정에 관해서는 닫혀있어야 한다는 원칙***
- 변경이 필요할 때, 기존 코드를 수정하지 않아야 한다는 말이다.   
- 코드의 안정성은 유지하되 요구사항의 변경에 유연하게 대처할 수 있다.   
  (기존 코드는 변경하지 않으므로 안정성이 유지됨)

### OCP 적용 방법
1. 변경(확장)될 것과 변하지 않을 것을 엄격히 구별
2. 두 모듈이 만나는 지점에 인터페이스 정의
3. 구현에 의존하기보다 인터페이스에 의존하도록 코드 작성

### 주의
- 확장되는 것과 변하지 않을 것을 분리하는 과정에서 오히려 관계가 복잡해질 수 있다.
- 인터페이스는 가능하면 변경되어서는 안 된다.(설계자는 적절한 수준의 예측 능력이 필요함)   
  추상화는 '구체적이지 않은'정도 라는 느슨한 개념을 가지고 있다.   
  (그래디 부치(Grady Booch)는   
  '추상화란 다른 모든 종류의 객체로부터 식별될 수 있는 객체의 본질적인 특징'이라고 정의하였다)

## L: LSP(Liskov Subsitution Principle: 리스코브 치환의 원칙)
***서브 타입은 언제나 기반 타입을 완벽하게 대체할 수 있어야 한다.***
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 서브 타입의 인스턴스로 바꿀 수 있어야 한다.
- 이를 지키기 위해서는 서브 타입의 객체가 기반 타입이 약속한 규약을 완벽히 지켜야 한다.

### LSP 적용 방법
**똑같은 연산을 제공할 경우**   
1. 똑같은 연산을 제공하지만, 이들이 약간 다르게 작동한다면 공통의 인터페이스를 만들고 둘이 이를 구현한다.(인터페이스 상속)

**공통된 연산이 없을 경우**   
1. 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만듭니다.
2. 추가적으로 무언가를 더 한다면 구현 상속을 사용한다.

**서브 클래스에서 조건을 변경하고 싶을 때**
- 서브 클래스에서는 기반 클래스의 사전 조건과 같거나 약한 수준으로 사전 조건을 대체할 수 있다.
- 서브 클래스에서는 기반 클래스의 사후 조건과 같거나 더 강한 수준으로 사후 조건을 대체할 수 있다.

기반 클래스를 서브 클래스로 치환 가능하게 하려면 받아들이는 선 조건에서는 느슨하거나 같아야 한다.   
강한 조건을 걸게 된다면 기반 클래스에서 실행되던 것이 실행되지 않을 수 있기 때문이다.   
그러므로 강한 조건을 걸고 싶다면 후 조건으로 걸어야 한다.   
반대로 후 조건을 약하게 걸게 되면 서브 클래스에서는 통과시키지 않을 상태를 통과할 수도 있기 때문에 주의해야 한다.

## I: (Interface Segregation Principle: 인터페이스 분리의 원칙)
***클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙***
- 인터페이스는 클라이언트에게 사용하지 않을 메서드를 강제로 구현하게 해서는 안된다.
- 필요한 기능들만 구현할 수 있도록 인터페이스를 작게 분리하여야 한다.
- SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임을 강조한다.

### ISP 적용 방법
- 인터페이스를 작은 단위로 분리한다.(기능 또는 역할로 분리)

## D: (Dependency Inversion Principle: 의존 관계 주입의 원칙)
***프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다는 원칙***
- 의존 관계를 맺을 때 변화하기 쉬운 것(구체화)보다는 변화하기 어려운 것(추상화)에 의존해야 함   
  이를 통해 하위 모듈(사용되는 클래스) 변경으로부터 상위 모듈(하위 모듈을 사용하는 클래스)이 영향을 받지 않도록 할 수 있다.
- 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙

### DIP 적용 방법
1. 추상화 인터페이스 정의
2. 구체화된 클래스는 필드를 인터페이스로 두고, 인터페이스를 통해 협력   
   (잘 구조화된 객체 지향 아키텍처들은 구현체들이 인터페이스를 레이어하는 서비스 집합 이룸)
   
## 참조
* [객체지향 개발 5대 원리: SOLID - 넥스트리소프트](https://www.nextree.co.kr/p6960)
